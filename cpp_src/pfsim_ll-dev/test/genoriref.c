#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define NG 45

#define PI 3.1415926

#define MISORIENTATIONS(i,j) misorientations[(i-1)*NG + (j-1)]

typedef struct mat{
	double a[3][3];
}mat;

mat symmetry[24]={
	1,  0,  0,  0,  1,  0,  0,  0,  1,
	0, -1,  0,  1,  0,  0,  0,  0,  1,
	-1,  0,  0,  0, -1,  0,  0,  0,  1,
	0,  1,  0, -1,  0,  0,  0,  0,  1,

	1,  0,  0,  0,  0, -1,  0,  1,  0,
	1,  0,  0,  0, -1,  0,  0,  0, -1,
	1,  0,  0,  0,  0,  1,  0, -1,  0,
	0,  0,  1,  0,  1,  0, -1,  0,  0,

	-1,  0,  0,  0,  1,  0,  0,  0, -1,
	0,  0, -1,  0,  1,  0,  1,  0,  0,
	0,  0,  1,  1,  0,  0,  0,  1,  0,
	0,  1,  0,  0,  0,  1,  1,  0,  0,

	0, -1,  0,  0,  0, -1,  1,  0,  0,
	0,  0,  1, -1,  0,  0,  0, -1,  0,
	0, -1,  0,  0,  0,  1, -1,  0,  0,
	0,  0, -1, -1,  0,  0,  0,  1,  0,

	0,  0, -1,  1,  0,  0,  0, -1,  0,
	0,  1,  0,  0,  0, -1, -1,  0,  0,
	0,  1,  0,  1,  0,  0,  0,  0, -1,
	0, -1,  0, -1,  0,  0,  0,  0, -1,

	-1,  0,  0,  0,  0,  1,  0,  1,  0,
	-1,  0,  0,  0,  0, -1,  0, -1,  0,
	0,  0,  1,  0, -1,  0,  1,  0,  0,
	0,  0, -1,  0, -1,  0, -1,  0,  0
};

void assign_orientation(mat ori[]){
	double a,b,c;
	int i;
	for(i=0;i<=NG;i++){
		a=((double) rand() / RAND_MAX * 360)*PI/180;
		b=acos((double) (rand()*2-1)/ RAND_MAX);
		c=((double) rand() / RAND_MAX* 360)*PI/180;

		ori[i].a[0][0]=cos(a)*cos(c)-sin(a)*sin(c)*cos(b);
		ori[i].a[0][1]=sin(a)*cos(c)+cos(a)*sin(c)*cos(b);
		ori[i].a[0][2]=sin(c)*sin(b);

		ori[i].a[1][0]=-cos(a)*sin(c)-sin(a)*cos(c)*cos(b);
		ori[i].a[1][1]=-sin(a)*sin(c)+cos(a)*cos(c)*cos(b);
		ori[i].a[1][2]=cos(c)*sin(b);

		ori[i].a[2][0]=sin(a)*sin(b);
		ori[i].a[2][1]=-cos(a)*sin(b);
		ori[i].a[2][2]=cos(b);
	}
}

double misorientation(int grain1,int grain2,mat ori[]){
	// function requires indexing from zero
	
	//calculating 
	
	mat rotation,trans_ori1,result;
	int i,j,k,n,m,l;

	float trace,max_trace,temp;

	trace = 0;
	max_trace = 0;

	for(i=0;i<3;i++){
		for(j=0;j<3;j++){
			trans_ori1.a[i][j] = ori[grain1].a[j][i];
		}
	}
	
	
// 	printf("transposed matrix grain a\n");
// 	for (int i=0; i<3; ++i) {
// 		for (int j=0; j<3; ++j) {
// 			printf("%lf ",trans_ori1.a[i][j]);
// 		}
// 		printf("\n");
// 	}
	

	for(i=0;i<3;i++){
		for(j=0;j<3;j++){
			temp=0;
			for(k=0;k<3;k++){
				temp += trans_ori1.a[i][k] * ori[grain2].a[k][j];
			}
			rotation.a[i][j]=temp;
		}
	}
	
// 	printf("rotation matrix: ");
// 	for (std::size_t i=0; i<9 ;++i) {
// 		printf("%lf ",rotation.a[i/3][i%3]);
// 	}
	printf("\n");

	for(n=0;n<24;n++){
		for(m=0;m<24;m++){
			trace=0;

			for(i=0;i<3;i++){
				for(j=0;j<3;j++){
					temp=0;
					for(k=0;k<3;k++){
						temp += rotation.a[i][k] * symmetry[n].a[k][j];
					}
					result.a[i][j]=temp;
				}
			}

			for(l=0;l<3;l++){
				trace+=result.a[l][l];
			}
			if(trace>max_trace) max_trace = trace;
		}
	}

	return acos((max_trace-1)/2)/PI*180;
}

void calculate_all_misorientations(float *misorientations, mat ori[]){
	int i,j;
	
	// indexing from 1
	for(i=1;i<=NG;i++){
		for(j=i;j<=NG;j++){
			
			// ERROR
			// call function using i and j that 
			// requires indexing from zero
			float angle = misorientation(i,j,ori);
			
			// write results to there indices
			//are decremented by 1
			if(i==j){
				MISORIENTATIONS(i,j) = angle;
			}else{
				MISORIENTATIONS(i,j) = angle;
				MISORIENTATIONS(j,i) = angle;
			}
		}
	}
}

int main() {
	mat vals[NG+1];

	assign_orientation(vals);
	
	for (int i=0; i<NG; ++i) {
			for (int j=0; j<3; ++j) {
					for (int l=0; l<3; ++l) {
						printf("%lf ",vals[i].a[j][l]);
					}
			printf("\n");
			}
			printf("\n");
	}
	
	// print vals
	/*
	for (int i=0; i<3; ++i) {
		for (int j=0; j<3; ++j) {
			printf("%lf ",vals[0].a[i][j]);
		}
		printf("\n");
	}
	*/

	float buf[NG*NG];
	

	/* following operation gives values
	 * other than generated by the cpp
	 * implementation
	 */
	calculate_all_misorientations(buf, vals);
	
	//this one here fails completely
	/*
	for (int i=1; i<=NG; ++i) {
		for (int j=1; j<=NG; ++j) {
			buf[3*i+j] = misorientation(i, j, vals);
		}
	}
	*/

	for (int i=0; i<NG; ++i) {
		for (int j=i+1; j<NG;++j) {
			printf("(%d, %d): %lf\n",i,j,buf[i+NG*j]);
		}
	}
	printf("\n");
}


